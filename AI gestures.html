<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Hand Controlled 3D Particles</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: Arial, sans-serif;
  }
  #ui {
    position: fixed;
    top: 10px;
    left: 10px;
    color: white;
    background: rgba(0,0,0,0.6);
    padding: 10px;
    border-radius: 8px;
    font-size: 14px;
  }
  video {
    display: none;
  }
</style>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>

<body>

<div id="ui">
  <div>üì∑ Camera: <span id="cameraStatus">Waiting</span></div>
  <div>‚ú® Mode: <span id="mode">Heart</span></div>
  <div>üñê Gesture: <span id="gesture">None</span></div>
  <div>‚å® Keys: 1‚Äì5 switch modes</div>
</div>

<video id="video" autoplay playsinline></video>

<script>
/* =========================
   THREE.JS SETUP
========================= */
let scene, camera, renderer;
let particles, geometry, material;
let positions;
const COUNT = 8000;

let currentMode = "Heart";

const handData = {
  spread: 0,
  x: 0,
  y: 0,
  depth: 0,
  gesture: "None"
};

initScene();
initParticles();
initHandTracking();
animate();

function initScene() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 60;

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

/* =========================
   PARTICLES
========================= */
function initParticles() {
  geometry = new THREE.BufferGeometry();
  positions = new Float32Array(COUNT * 3);
  geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

  material = new THREE.PointsMaterial({
    size: 0.6,
    color: 0xff3366,
    transparent: true
  });

  particles = new THREE.Points(geometry, material);
  scene.add(particles);

  generateShape();
}

function generateShape() {
  for (let i = 0; i < COUNT; i++) {
    const i3 = i * 3;
    let x, y, z;
    const t = Math.random() * Math.PI * 2;

    switch (currentMode) {
      case "Heart":
        x = 16 * Math.pow(Math.sin(t), 3);
        y = 13 * Math.cos(t) - 5 * Math.cos(2*t);
        z = (Math.random() - 0.5) * 5;
        break;

      case "Flower":
        const r = 10 * Math.sin(5 * t);
        x = r * Math.cos(t);
        y = r * Math.sin(t);
        z = (Math.random() - 0.5) * 5;
        break;

      case "Saturn":
        const ring = 20 + Math.random() * 5;
        x = Math.cos(t) * ring;
        y = (Math.random() - 0.5) * 2;
        z = Math.sin(t) * ring;
        break;

      case "Fireworks":
        x = (Math.random() - 0.5) * 40;
        y = (Math.random() - 0.5) * 40;
        z = (Math.random() - 0.5) * 40;
        break;

      default: // Spiral
        const a = i * 0.1;
        x = Math.cos(a) * a * 0.1;
        y = Math.sin(a) * a * 0.1;
        z = (Math.random() - 0.5) * 10;
    }

    positions[i3] = x;
    positions[i3 + 1] = y;
    positions[i3 + 2] = z;
  }
  geometry.attributes.position.needsUpdate = true;
}

/* =========================
   HAND TRACKING
========================= */
function initHandTracking() {
  const video = document.getElementById("video");

  const hands = new Hands({
    locateFile: file =>
      `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });

  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });

  hands.onResults(results => {
    if (!results.multiHandLandmarks) return;

    const lm = results.multiHandLandmarks[0];
    const thumb = lm[4];
    const index = lm[8];

    const dx = thumb.x - index.x;
    const dy = thumb.y - index.y;
    const distance = Math.sqrt(dx*dx + dy*dy);

    handData.spread = Math.min(distance * 5, 1);
    handData.x = (lm[0].x - 0.5) * 2;
    handData.y = (lm[0].y - 0.5) * -2;
    handData.depth = -lm[0].z;

    handData.gesture = distance < 0.05 ? "Pinch" : "Open";
    document.getElementById("gesture").textContent = handData.gesture;
  });

  const cam = new Camera(video, {
    onFrame: async () => {
      await hands.send({ image: video });
    },
    width: 640,
    height: 480
  });

  navigator.mediaDevices.getUserMedia({ video: true })
    .then(() => {
      document.getElementById("cameraStatus").textContent = "Granted";
      cam.start();
    })
    .catch(() => {
      document.getElementById("cameraStatus").textContent = "Denied";
    });
}

/* =========================
   ANIMATION LOOP
========================= */
function animate() {
  requestAnimationFrame(animate);

  const scale = THREE.MathUtils.lerp(1, 4, handData.spread);
  particles.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.1);

  material.color.setHSL(
    0.9 - handData.depth * 0.5,
    1,
    0.6
  );

  particles.rotation.y += handData.x * 0.002;
  particles.rotation.x += handData.y * 0.002;

  renderer.render(scene, camera);
}

/* =========================
   KEYBOARD MODE SWITCH
========================= */
window.addEventListener("keydown", e => {
  const modes = ["Heart", "Flower", "Saturn", "Fireworks", "Spiral"];
  if (e.key >= "1" && e.key <= "5") {
    currentMode = modes[e.key - 1];
    document.getElementById("mode").textContent = currentMode;
    generateShape();
  }
});
</script>

</body>
</html>